// cmd/server/main.go

// @title           Bookshelf API
// @version         1.0
// @description     Mini Book Management API (Gin + GORM + JWT)
// @schemes         http
// @BasePath        /
//
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
package main

import (
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"

	// swagger docs (generated by swag init)
	_ "github.com/giovannyptr/bookshelf/docs"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"

	// internal
	"github.com/giovannyptr/bookshelf/internal/auth"
	"github.com/giovannyptr/bookshelf/internal/books"
	"github.com/giovannyptr/bookshelf/internal/users"
	"github.com/giovannyptr/bookshelf/models"

	"golang.org/x/crypto/bcrypt"
)

func getenv(k, d string) string {
	if v := strings.TrimSpace(os.Getenv(k)); v != "" {
		return v
	}
	return d
}

func main() {
	// ---- env ----
	port := getenv("PORT", "8080")
	dsn := getenv("DATABASE_URL", "")
	if dsn == "" {
		host := getenv("DB_HOST", "127.0.0.1")
		dbPort := getenv("DB_PORT", "5433")
		user := getenv("DB_USER", "bookshelf")
		pass := getenv("DB_PASSWORD", "bookshelf")
		name := getenv("DB_NAME", "bookshelf")
		ssl := getenv("DB_SSLMODE", "disable")
		dsn = "postgres://" + user + ":" + pass + "@" + host + ":" + dbPort + "/" + name + "?sslmode=" + ssl
	}
	log.Printf("DEBUG CWD=%s", must(os.Getwd()))
	log.Printf("DEBUG DATABASE_URL=%q\n", dsn)

	adminEmail := strings.ToLower(getenv("ADMIN_EMAIL", "admin@mail.com"))
	adminPassword := getenv("ADMIN_PASSWORD", "adminbookshelf")
	allowedOrigins := getenv("ALLOWED_ORIGINS", "*")

	// ---- db ----
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("failed to connect database: %v", err)
	}
	log.Println("‚úÖ Connected to PostgreSQL successfully")

	// ---- migrations ----
	if err := db.AutoMigrate(&models.User{}, &models.Book{}); err != nil {
		log.Fatalf("auto-migrate error: %v", err)
	}
	log.Println("üìò Auto-migration completed")

	// ---- seed admin ----
	ur := users.NewRepository(db)
	if _, err := ur.ByEmail(adminEmail); err != nil {
		hash, _ := bcrypt.GenerateFromPassword([]byte(adminPassword), bcrypt.DefaultCost)
		u := models.User{Email: adminEmail, Password: string(hash), Name: "Admin", Role: "admin"}
		if err := ur.Create(&u); err == nil {
			log.Printf("‚úÖ Admin user created: %s\n", adminEmail)
		} else {
			log.Printf("‚ö†Ô∏è  Failed to seed admin user: %v\n", err)
		}
	}

	// ---- gin ----
	gin.SetMode(gin.DebugMode)
	r := gin.New()
	r.Use(gin.Logger(), gin.Recovery())

	// ---- CORS ----
	cfg := cors.Config{
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}
	if allowedOrigins == "*" {
		cfg.AllowAllOrigins = true
	} else {
		parts := strings.Split(allowedOrigins, ",")
		for i := range parts {
			parts[i] = strings.TrimSpace(parts[i])
		}
		cfg.AllowOrigins = parts
	}
	r.Use(cors.New(cfg))

	// ---- static uploads ----
	uploadDir := "./uploads"
	_ = os.MkdirAll(uploadDir, 0o755)
	r.Static("/uploads", filepath.Clean(uploadDir))

	// ---- health ----
	// @Summary Health check
	// @Tags    misc
	// @Produce json
	// @Success 200 {object} map[string]any
	// @Router  /health [get]
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok", "time": time.Now()})
	})

	// ---- auth ----
	ah := auth.NewHandler(ur)
	ah.RegisterRoutes(r)

	// ---- books ----
	br := books.NewRepository(db)
	bh := books.NewHandler(br, uploadDir)

	api := r.Group("/")
	api.GET("/books", bh.List)
	api.GET("/books/:id", bh.Detail)
	api.POST("/books", auth.AuthRequired(), bh.Create)
	api.PUT("/books/:id", auth.AuthRequired(), bh.Update)
	api.DELETE("/books/:id", auth.AuthRequired(), bh.Delete)

	// ---- swagger ui ----
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	log.Printf("üöÄ Server running on http://localhost:%s\n", port)
	if err := r.Run(":" + port); err != nil {
		log.Fatal(err)
	}
}

func must[T any](v T, _ error) T { return v }
